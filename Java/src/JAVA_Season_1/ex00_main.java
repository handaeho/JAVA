package JAVA_Season_1;

public class ex00_main {
    public static void main(String[] args) {
        /*
        main 메소드: 제일 먼저 실행 되는 메소드 ~> 메소드: 객체에 대한 동작
        1) public = 접근 제한자.
            - public: 모든 클래스에서 접근 가능
            - protected: 같은 패키지에 있는 클래스 또는 상속관계에 있는 클래스들만 접근 허용
            - default: 같은 패키지에 있는 클래스만 접근 허용
            - private: 현재 클래스에서만 접근 허용
           main 메소드가 제일 먼저 실행되기 때문에 정의만 하고 다른 곳에서 호출하는 동작은 사용할 수 없다.

         2) static = 이 함수는 '정적 함수'
         ~> static으로 함수 또는 클래스 선언시, 해당 객체는 컴파일 되는 순간 정의가 됨.
            그리고 이후에 static이 아닌 객체가 정의가 된다.
            따라서 일단 static 객체에서 static이 아닌 객체를 호출하는 것은 불가능.
            static이 먼저 정의되기 때문에 아직 정의되지 않은 객체는 호출할 수 없기 때문이다.

         정적 언어: C, C#, C++, JAVA 등
         = 변수에 들어가는 데이터에 따라 변수 타입을 지정해 주어야만 함. 안정적이고 속도가 빠름
         동적 언어: Python, Ruby, JAVA Script 등
         = 데이터 타입을 결정하지 않고 컴파일 할 수 있음. 간편하지만 무겁고 느림

         static
         ~> 클래스를 만들 때, 모든 객체가 공통적으로 참조하는 변수가 있다면
         static을 사용하여 하나의 변수만 생성하고 모든 객체가 제어 할 수 있다.
         즉, 고정되어 한 번만 생성하고 모든 객체가 참조 가능한 것이다.

         static 변수는 객체의 변수가 아닌 '클래스의 변수'라고 할 수 있다.
         그렇기 때문에 모든 객체가 같은 주소로 참조 할 수 있다.
         일반적으로 클래스의 변수나 메소드는 객체를 생성해야만 사용할 수 있는데,
         static으로 선언된 변수나 메소는 객체를 생성하지 않고도 사용할 수 있다.

         일반적으로 클래스가 설계도라면 객체를 생성해야지만 메모리에 적재되고 변수에 값이 들어가지만
         static의 경우 JVM이 클래스를 읽어 들일 때, 자동으로 메모리에 적재된다.

         예를 들어, Math.random()에서 Math는 이미 정의된 클래스이고 그 안의 random 메소드를 사용하는 것인데
         random 메소드는 static 메소드이기 때문에 Math 객체를 생성하지 않아도 사용할 수 있는 것이다.

         따라서 메인 클래스의 static은 객체를 생성하지 않고 메소드를 호출할 수 있다는 것이다.
         메인 메소드의 호출은 JVM에서 호출되기 때문에 객체 생성 없이 메모리에 할당시켜 호출 가능한 형태로 만들어야 하기 때문

         JVM은 메인 클래스의 객체를 생성하지 않고 클래스의 static으로 선언돈 메소드를 객체 생성없이 메모리에 할당하고
         할당된 메소드 중 'main'으로 이름이 붙은 메소드를 호출하게 되는 것.

         그렇기 때문에 main 메소드는 반드시 static으로 정의하는 것이다.
         */

    }
}
